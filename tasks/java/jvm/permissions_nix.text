// +build linux darwin

package jvm

import (
	"errors"
	"fmt"
	"os"
	"os/user"
	"path/filepath"
	"regexp"
	"syscall"

	log "github.com/newrelic/newrelic-diagnostics-cli/logger"
	"github.com/newrelic/newrelic-diagnostics-cli/tasks"
	"github.com/newrelic/newrelic-diagnostics-cli/tasks/java/env"
	"github.com/shirou/gopsutil/process"
)

var (
	fileOwnerReadPermissionsRgx = "-r.+"
	groupReadPermissionsRgx     = "[rwx-]{4}r.+"
	readPermissionsRgx          = "[rwx-]{7}r.+"
)

/* PermissionsPayload - struct used to construct the eventual result payload */
type PermissionsPayload struct {
	PID                int32
	AgentJarCanRead    payloadField //The owner of the Java process to which the -javaagent option will be passed must have read permissions for the java agent JAR
	LogDirCanCreate    payloadField //The process owner requires write/execute permissions for the directory in which the log directory will be created and execute permissions for all parent directories of the log directory so the java process can traverse into the directory and create the java agent log file
	LogFileCanCreate   payloadField
	LogFileCanWrite    payloadField
	TempFilesCanCreate payloadField //The process owner must have write/execute access to the temp directory for the Java process. This may be the default directory for temporary Java files (specified system-wide), or it may be one specific to the process,
}

/* struct used to store if permissions are set correctly for a file/dir and if an error was encountered while determining permissions*/
type payloadField struct {
	Success  bool
	ErrorMsg error
	Source   string
	Value    string
}

var tempDir = []string{
	"-Dnewrelic.tempdir", //can only be set as sys prop not as an env var neither the config file
	"-Djava.io.tmpdir",   //On UNIX systems the default value of this property can be "/tmp" or "/var/tmp"; on Windows "c:\temp". A different path value may be given through this system property
}

var (
	//will import logPathConfigFileSource which uses log_file_path + log_filename. If the former has been is specified, the directory must already exist
	logPathDefaultSource = "/logs/" //there will a logs dir in the same location where jar was found.Ex: newrelic/newrelic.jar/logs/newrelic_agent.log
	logPathEnvVarSource  = "NEW_RELIC_LOG"//The unqualified log file name(not a path) or the string STDOUT which will log to standard out. The latter would inmediately give a "permission denied" error so no much need to troubleshoot for this option
	logPathSysPropSource = "-Dnewrelic.logfile"//EX: Dnewrelic.logfile=/opt/newrelic/java/logs/newrelic/somenewnameformylogs.log
	logPathConfigFileSource = "log_file_path"
	envVarSource         = "environment variable"
	sysPropSource        = "system property or JVM arg"
	yamlSource           = "configuration file"
	defaultSource        = "New Relic Java Agent Default"
)

type JavaJVMPermissions struct {
}

// Identifier - returns the Category (Agent), Subcategory (Java) and Name (Permissions)
func (p JavaJVMPermissions) Identifier() tasks.Identifier {
	return tasks.IdentifierFromString("Java/JVM/Permissions") // This should be updated to match the struct name
}

// Explain - Returns the help text for the customer for this task
func (p JavaJVMPermissions) Explain() string {
	return "Check Java process permissions meet New Relic Java agent requirements"
}

/* Dependencies - Depends on the the SysPropCollect task to get PIDs with corresponding command-line args */
func (p JavaJVMPermissions) Dependencies() []string {
	return []string{
		"Base/Env/CollectEnvVars",
		"Base/Env/CollectSysProps",
		"Base/Log/Copy",
		"Java/Env/Process",
	}
}

/* Execute - This task checks for processes running new relic java agents and determines if permissions are set correctly to run the Agent */
func (p JavaJVMPermissions) Execute(options tasks.Options, upstream map[string]tasks.Result) tasks.Result {
	/* if there are no running Java Agents */
	if upstream["Java/Env/Process"].Status != tasks.Success {
		return tasks.Result{
			Status:  tasks.None,
			Summary: "The New Relic agent has not been added to a running JVM process yet. This task did not run.",
		}
	}

	/* if there is at least one running Java Agent */
	/* obtain slice of java processes and command-line args from SysPropCollect task */
	javaProcs, ok := upstream["Java/Env/Process"].Payload.([]env.ProcIdAndArgs)
	if !ok {
		return tasks.Result{
			Status:  tasks.None,
			Summary: "We were unable to run this health check due to an internal type assertion error for the task Java/Env/Process",
		}
	}
	var permissionsPayload *PermissionsPayload
	for _, process := range javaProcs {
		/* Can the user read the Agent JAR */
		determineJarPermissions(process.Proc, process.JarPath, permissionsPayload)
		/* can the user create the log directoy for the agent */
		determineLogDirPermissions(process.Proc, upstream, permissionsPayload)
	}
	//pass the path to the jar + "/logs" + envvarfilename
	// logDir := getLogDirectory(upstream)

}

func determineLogDirPermissions(proc process.Process, upstream map[string]tasks.Result, permissionsPayload *PermissionsPayload) string {
	//check for stdout
	var logPath string
	//though env var takes precedence over sys prop, it is not possible to set log directory through env var, only log filename
	sysPropLogPath := findPathInSysProp(upstream, proc)

	if sysPropLogPath != "" {
		logPath = sysPropLogPath
	} else {
		//look for value in config file

	}
	// envVars, ok := upstream["Base/Env/CollectEnvVars"].Payload.(map[string]string)
	// if !ok {
	// 	log.Debug("Upstream environment variables check failed.")
	// }
}

func findPathInSysProp(upstream map[string]tasks.Result, proc process.Process) string {
	if upstream["Base/Env/CollectSysProps"].Status == tasks.Info {
		processes, ok := upstream["Base/Env/CollectSysProps"].Payload.([]tasks.ProcIDSysProps)
		if ok {
			for _, process := range processes {
				if process.ProcID == proc.Pid {
					logPathKey := logFile["sysProp"]
					logPathVal, isPresent := process.SysPropsKeyToVal[logPathKey]
					if isPresent {
						return logPathVal
					}
				}
			}
		}
	}
	return ""
}

/* need read permissions only; "java" is being executed and it needs to read the JAR */
func determineJarPermissions(proc process.Process, jarLoc string, permissionsPayload *PermissionsPayload) {
	/* check if the Java Agent JAR exists */
	var agentJARReadError error
	if _, errJarNotExist := os.Stat(jarLoc); os.IsNotExist(errJarNotExist) {
		agentJARReadError = fmt.Errorf(`Agent JAR does not exist for PID %d. This location is at %s: %s`, proc.Pid, jarLoc, errJarNotExist)
	}
	procOwnerUID, procOwnerGID, fileOwnerUID, fileOwnerGID, err := getFileAndProcUIDsGIDs(proc, jarLoc)
	fmt.Println("luces 0:", procOwnerUID, procOwnerGID, fileOwnerUID, fileOwnerGID, err)
	if err != nil {
		agentJARReadError = err
	}

	info, errGettingJarPerms := os.Stat(jarLoc)
	if errGettingJarPerms != nil {
		agentJARReadError = fmt.Errorf("There was an error obtaining JAR permissions for JAR at " + jarLoc + ". Error is: " + errGettingJarPerms.Error())
	}
	filePerm := info.Mode().Perm()
	fmt.Println("luces 1:", jarLoc, filePerm)
	/* the process owner also is the file owner for the Agent JAR */
	if procOwnerUID == fileOwnerUID {
		matched, errRegexMatch := regexp.MatchString(fileOwnerReadPermissionsRgx, filePerm.String())
		if errRegexMatch != nil {
			agentJARReadError = errRegexMatch
		}
		if !matched {
			/* the process/file owner has read permissions */
			agentJARReadError = errors.New("The owner of the process for PID " + fmt.Sprint(proc.Pid) + "does not have permissions to execute the New Relic Agent JAR located at " + jarLoc + " : " + filePerm.String())
		}
		/* the process owner is part of the group to which the Agent JAR belongs */
	} else if procOwnerGID == fileOwnerGID {
		matched, errRegexMatch := regexp.MatchString(groupReadPermissionsRgx, filePerm.String())
		if errRegexMatch != nil {
			agentJARReadError = errRegexMatch
		}
		if !matched {
			/* the file group has read permissions */
			agentJARReadError = errors.New("The owner of the process for PID " + fmt.Sprint(proc.Pid) + "does not have permissions to execute the New Relic Agent JAR located at " + jarLoc + " : " + filePerm.String())
		}
	} else {
		/* process owner is neither the Agent JAR file owner nor part of the JAR's specified group */
		matched, errRegexMatch := regexp.MatchString(readPermissionsRgx, filePerm.String())
		if errRegexMatch != nil {
			agentJARReadError = errRegexMatch
		}
		if !matched {
			/* all have read permissions */
			agentJARReadError = errors.New("The owner of the process for PID " + fmt.Sprint(proc.Pid) + "does not have permissions to execute the New Relic Agent JAR located at " + jarLoc + " : " + filePerm.String())
		}
	}
	//assign permissionsPayload values to Jar

	permissionsPayload.PID = proc.Pid
	permissionsPayload.AgentJarCanRead.Success = (agentJARReadError == nil)
	permissionsPayload.AgentJarCanRead.Source = sysPropSource
	permissionsPayload.AgentJarCanRead.Value = jarLoc
	permissionsPayload.AgentJarCanRead.ErrorMsg = agentJARReadError
}

func getFileAndProcUIDsGIDs(proc process.Process, file string) (string, string, string, string, error) {
	procOwner, _ := proc.Username()
	procOwnerUser, err := user.Lookup(procOwner)
	if err != nil {
		return "", "", "", "", fmt.Errorf("Problem with Lookup. Error is: ", err)
	}
	procOwnerUID := procOwnerUser.Uid
	procOwnerGID := procOwnerUser.Gid
	info, err := os.Stat(file)
	if err != nil {
		return "", "", "", "", fmt.Errorf("Problem with os.Stat while determining process/file permissions for PID "+fmt.Sprint(proc.Pid)+". Error is: ", err)
	}
	fileModeInfo := info.Sys()
	fileOwner := fileModeInfo.(*syscall.Stat_t)
	fileOwnerUID := fmt.Sprint(fileOwner.Uid)
	fileOwnerGID := fmt.Sprint(fileOwner.Gid)
	return procOwnerUID, procOwnerGID, fileOwnerUID, fileOwnerGID, nil
}

/* process owner needs write/execute permissions for dir in which to create log dir */
func canCreateLogDirectory(proc process.Process, LogPath string) (err error) {
	/* logs directory already exists; return success */
	if _, errDirExist := os.Stat(LogPath); errDirExist == nil {
		err = errDirExist
		return
	}
	truncatedLog := filepath.Dir(LogPath)
	/* the logs directory does not already exist and the directory in which the logs directory will be created does not exist */
	if _, errDirExist := os.Stat(truncatedLog); os.IsNotExist(errDirExist) {
		err = errDirExist
		return
	}
	procOwnerUID, procOwnerGID, fileOwnerUID, fileOwnerGID := getFileAndProcUIDsGIDs(proc, truncatedLog)
	if procOwnerUID == "" && procOwnerGID == "" && fileOwnerUID == "" && fileOwnerGID == "" {
		err = errors.New("The permissions settings to create Agent log directory are indeterminable")
		return
	}
	info, errStatDir := os.Stat(truncatedLog)
	if errStatDir != nil {
		log.Debug(taskName, "Error determining directory permissions. Error is: ", err)
		err = errStatDir
		return
	}
	filePerm := info.Mode().Perm()
	/* the process owner also is the directory owner */
	if procOwnerUID == fileOwnerUID {
		matched, errRegexMatch := regexp.MatchString("[drwx-]{2}wx.+", fmt.Sprint(filePerm))
		if errRegexMatch != nil {
			log.Debug(taskName, errRegexMatch)
			err = errRegexMatch
			return
		}
		if matched {
			/* the process/dir owner has write permissions */
			return
		}
	} else if procOwnerGID == fileOwnerGID {
		/* the process owner is part of the dir group */
		matched, errRegexMatch := regexp.MatchString("[drwx-]{5}wx.+", fmt.Sprint(filePerm))
		if err != nil {
			log.Debug(taskName, errRegexMatch)
			err = errRegexMatch
			return
		}
		if matched {
			/* the dir group has write permissions */
			return
		}
	} else {
		/* process owner is neither the dir owner nor part of the dir's specified group */
		matched, errRegexMatch := regexp.MatchString("[drwx-]{8}wx", fmt.Sprint(filePerm))
		if errRegexMatch != nil {
			log.Debug(taskName, errRegexMatch)
			err = errRegexMatch
			return
		}
		if matched {
			/* all have write permissions */
			return
		}
	}
	err = errors.New("The owner of the process does not have permissions to create the Agent log directory")
	return
}
